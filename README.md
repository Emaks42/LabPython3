# Лабораторная работа 3
### Вариант Medium
### Выполнил Максимов Егор М8О-103БВ-25

## Введение
В рамках этой лабораторной работы написан алгоритмический мини-макет, с CLI интерфейсом


## Структура проекта

 <pre>
    .
    ├── LabPython3             # Кодовая база лабораторной работы
    │   ├── src/                               # Исходный код
    │   ├── tests/                             # Unit тесты
    │   ├── uv.lock                            # зависимости проекта
    │   ├── .gitignore                         # git ignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание проекта
</pre>

В папке [src](./src) лежат файлы с реализацией задачи данной в лабораторной работы. Осонвным файлом является файл
[main.py](./src/main.py) в котором описана точка входа в приложение - функция **main**. Также в этой папке лежат файлы
[functions.py](./src/functions.py) - функции вычисления чисел Фибоначчи и факториала, [sortings.py](./src/sortings.py) -
6 видов сортировок, [heap.py](./src/heap.py) - содержит класс двоичной кучи, используемый в одной из сортировок и
[generators.py](./src/generators.py) - функции, генерирующие массивы чисел разных видов, [stack.py](./src/stack.py) -
содержит класс стека, реализованный на связанном списке, [constants.py](./src/constants.py) - константы, необходимые для
работы пограммы.



В папке [tests](./tests) лежат **unit** тесты для проверки функциональности программы и её частей.
Используется библиотека pytest. В файле [func_test.py](./tests/func_test.py) лежат тесты для функций из файла
[functions.py](./src/functions.py), в файле [sort_test.py](./tests/sort_test.py) лежат тесты для алгоритмов сортировки,
в файле [sort_test.py](./tests/stack_test.py) лежат тесты для структуры данных - стека,

В качестве пакетного менджера в данном репозитории используется [uv](https://github.com/astral-sh/uv).

## Допущения
<ul>
<li>bucket sort применяется только к вещественным числам от 0 до 1</li>
<li>факториал 0 равен 1</li>
<li>в counting и radix sort применяются только целые числа</li>
<li>с помощью команды exec в CLI интерфейсе пользователь не будет пытаться сломать систему (если что там есть банворды) :)</li>
</ul>

## Алгоритм решения
### CLI

CLI предлагает пользователю последовательно выбирать из нескольких пунктов
<ol>
<li>Пользователь вводит цифру или специальную команду или exit для завершения работы программы</li>
<li>если пользователь применяет команду, то она обрабатывается в первую очередь иначе пользователю предлагается следющий выбор</li>
<li>при использовании команды она выполняется сразу, если применяется выбор цифр, то соответствующая функция берётся из
словаря</li>
</ol>
Также в хотел бы отметить, что в программе есть проверка "банвордов" для exec

### Особенности реализации функций вычисления чисел Фибоначчи и факториала
<ul>
<li>Обе функции применимы только к числам больше или равным 0</li>
<li>Для вычисления чисел Фибоначчи без рекурсии применется решение соответствуюего им рекуррентного соотношения</li>
</ul>

### Особенности реализации функций сортировок
<ul>
<li>в radix sort применяется алгоритм LSD</li>
<li>в counting sort при слишком большой разнице между максимальным и минимальном элементе выводится Warning о возможности
переполнения памяти</li>
<li>в алгоритмах quick, bubble и heap sort есть возможность ввести ключи и компаратор</li>
<li>в файле с сортировками лежат функции-макеты для ключа и компаратора</li>
<li>для реализации алгоритма сортировки heap sort создан дополнительный класс двоичной кучи со своими методами</li>
<li>в bucket sort каждое "ведро" сортируется алгоритмом quick sort</li>
</ul>

### Особенности реализации структуры данных - стека
<ul>
<li>Стек реализован на основе связанного списка, где каждый элемент знает только следующий после себя</li>
<li>В классе есть два указателя на ноду - memory и quick_access_memory, соответственно указатель на начало стека и на
последние 5-10 элементов</li>
<li>при изменениии размера стека происходит проверка, не закончислась или не переполнилась ли quick_access_memory, если
такая ситуация имеет место, то происходит сдвиг указателя quick_access_memory</li>
<li>использование quick_access_memory помогает сделать время работы команд push и pop константным, в большей части случаев</li>
<li>в стеке есть возможность поиска минимума за константное время (обеспечивается также с помощью quick_access_memory и
хранением в ноде не только элемента стека, но и минимума на момент добавления элемента в стек)</li>
</ul>

**Замечание:** так как в ТЗ к лабораторной работе было указано, что в классе ноды должна храниться именно следующая (Node(value,
**next**)), то были предприняты вышеописанные меры оптимизации

### Особенности реализации функций генерации тестовых массивов и бенчмаркинга
<ul>
<li>в ТЗ к лабораторной работе было не указанно наличие семени генерации для массива, отсортированного в обратном порядке,
оно было добавлено</li>
<li>Для замера времени работы сортитровок они применяются по 1000 раз к каждому массиву и берётся общее время</li>
</ul>

## Бенчмаркинг
<pre>
                                    bubble |                 quick |                 radix |              counting |                  heap |                bucket |                 lenin |       standart python |
         common array  0.03725530110436375 |  0.000804043246069341 |  0.000108810133926454 | 6.551195285283029e-05 |  0.004344985530929989 |                    -1 | 9.749535920855124e-05 | 3.4556948667159305e-0 |
  nearly sorted array  0.03762032643085695 | 0.0013273141073877922 | 0.0002575464739202289 | 0.0007574284251750214 | 0.0052543282670085316 |                    -1 | 0.0001015139111696044 | 4.046068148454651e-06 |
 reverse sorted array 0.038831189395990805 | 0.0013281515201961156 | 0.0002450668890232919 | 0.0007332379067811417 |  0.005141522703037481 |                    -1 | 0.0001011734339117538 | 4.093530151294544e-06 |
many duplicates array 0.038535257456052935 | 0.0005242761442059418 | 0.0001675955517275724 | 0.0001560870768589666 |  0.003720055342899286 |                    -1 | 9.842656124965288e-05 | 4.317361046560109e-06 |
          float array 0.039666434028855294 | 0.0013441191585734486 |                    -1 |                    -1 |    0.0052648469129781 | 0.0009337463680421933 | 0.0001079154802282573 | 5.023298028390855e-06 |
</pre>

В данной таблице приведены результаты работы 1000 раз алгоритмов сортировки с соответствующими названиями, время приведено
в секундах, если в таблице написано -1, то сортировка не применима к данному виду массива

Из таблицы можно сделать следующие выводы:
<ul>
<li>bubble sort гораздо медленнее всех остальных</li>
<li>все алгоритмы хуже справляются с почти отсортирванными массивами и отсортированными в обратном порядке</li>
<li>Самое быстрое, в среднем, время работы у radix sort</li>
<li>деление массива на "вёдра" увеличивает скорость работы алгоритма</li>
<li>lenin sort - дополнительный алгоритм сортировки, написан на основе алгоритма stalin sort</li>
</ul>

## Тестирование
Для тестирования используется модуль pytest. Также используется возможность pytest.mark.parametrize.

### Тестовые файлы

Тесты в каждом файле разделены по следующему принципу: сначала тесты базаовой работы функций, дальше идёт тестирование ошибок.
Тестирование генераторов производится параллельно тестированию сортировок.

### Примеры тестов

Тест корректности работы факториала

<pre>
@pytest.mark.parametrize("inp,expected", [(num, int(fact_math(num))) for num in range(20)])
def test_factorial(inp, expected):
    assert factorial(inp) == expected
</pre>

Для тестирования используется функция из библиотеки math (переименованна для избежания ошибок совпадения имён)

Тест корректности вычисления чисел Фибоначчи

<pre>
@pytest.mark.parametrize("inp,expected", [(1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8), (7, 13), (8, 21), (9, 34)])
def test_fibo_recursive(inp, expected):
    assert fibo_recursive(inp) == expected
</pre>

Для тестирования используются заранее вычисленные значения чисел Фибоначчи

Проверка обработки некорректного ввода в факториал и числа Фибоначчи

<pre>
def test_error_less_than_zero():
    with pytest.raises(ValueError):
        fibo_recursive(-1)
    with pytest.raises(ValueError):
        fibo(-1)
    with pytest.raises(ValueError):
        factorial_recursive(-1)
    with pytest.raises(ValueError):
        factorial(-1)
</pre>

Так как ошибка одинакова для всех функций, то решено не разделять её проверку на несколько тестов

Тестирование сортировки (на примере quick sort)

<pre>
@pytest.mark.parametrize("inp,expected", [(many_duplicates(100, 20, 42), sorted(many_duplicates(100, 20, 42))),
                                          (reverse_sorted(100, 42), sorted(reverse_sorted(100, 42))),
                                          (rand_int_array(100, 40, 120, seed=42),
                                           sorted(rand_int_array(100, 40, 120, seed=42))),
                                          (rand_float_array(100, 0, 1, 42), sorted(rand_float_array(100, 0, 1, 42))),
                                          (nearly_sorted(100, 20, 42), sorted(nearly_sorted(100, 20, 42)))])
def test_quick(inp, expected):
    assert quick_sort(inp) == expected
</pre>

Хотел бы отметить один интересный момент: стандартная функция sorted по неизвестной причине плохо обрабатывает число 38,
можете сами в этом убедиться

Ошибки при использовании сортировок

<pre>
def test_sort_errors():
    with pytest.raises(ValueError):
        bucket_sort([1000])
    with pytest.raises(ValueError):
        counting_sort([1.000])
    with pytest.raises(ValueError):
        radix_sort([1.000])
    with pytest.raises(ValueError):
        radix_sort([1, 2, 4, 1], -1)
</pre>

Базовая проверка корректности работы стека

<pre>
def test_base_stack_work():
    stack = Stack()
    for i in range(100):
        stack.push(i)
    for i in range(100):
        assert 100 - 1 - i == stack.pop()
</pre>

также этот тест дает возможность проверить корректность работы quick_access_memory

Все тесты в сумме покрывают примерно 82% кода из src. Всего есть ~86 тестов.
