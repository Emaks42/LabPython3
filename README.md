# Лабораторная работа 3
### Вариант Medium
### Выполнил Максимов Егор М8О-103БВ-25

## Введение
В рамках этой лабораторной работы написан алгоритмический мини-макет, с CLI интерфейсом


## Структура проекта

 <pre>
    .
    ├── LabPython3             # Кодовая база лабораторной работы
    │   ├── src/                               # Исходный код
    │   ├── tests/                             # Unit тесты
    │   ├── uv.lock                            # зависимости проекта
    │   ├── .gitignore                         # git ignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание проекта
</pre>

В папке [src](./src) лежат файлы с реализацией задачи данной в лабораторной работы. Осонвным файлом является файл
[main.py](./src/main.py) в котором описана точка входа в приложение - функция **main**. Также в этой папке лежат файлы
[functions.py](./src/functions.py) - функции вычисления чисел Фибоначчи и факториала, [sortings.py](./src/sortings.py) -
6 видов сортировок, [heap.py](./src/heap.py) - содержит класс двоичной кучи, используемый в одной из сортировок и
[generators.py](./src/generators.py) - функции, генерирующие массивы чисел разных видов, [stack.py](./src/stack.py) -
содержит класс стека, реализованный на связанном списке.



В папке [tests](./tests) лежат **unit** тесты для проверки функциональности программы и её частей.
Используется библиотека pytest. В файле [func_test.py](./tests/func_test.py) лежат тесты для функций из файла
[functions.py](./src/functions.py), в файле [sort_test.py](./tests/sort_test.py) лежат тесты для алгоритмов сортировки,
в файле [sort_test.py](./tests/stack_test.py) лежат тесты для структуры данных - стека,

В качестве пакетного менджера в данном репозитории используется [uv](https://github.com/astral-sh/uv).

## Допущения
<ul>
<li>bucket sort применяется только к вещественным числам от 0 до 1</li>
<li>факториал 0 равен 1</li>
<li>в counting и radix sort применяются только целые числа</li>
<li>время работы heap sort выше из-за использования класса (предположительно)</li>
<li>с помощью команды exec в CLI интерфейсе пользователь не будет пытаться сломать систему :)</li>
</ul>

## Алгоритм решения
### CLI

CLI предлагает пользователю последовательно выбирать из нескольких пунктов
<ol>
<li>Пользователь вводит цифру или специальную команду или exit для завершения работы программы</li>
<li>если пользователь применяет команду, то она обрабатывается в первую очередь иначе пользователю предлагается следющий выбор</li>
<li>при использовании команды она выполняется сразу, если применяется выбор цифр, то соответствующая функция берётся из
словаря</li>
</ol>
Также в классе есть функция для получения текущей директории get_current_directory

### Особенности реализации функций вычисления чисел Фибоначчи и факториала
<ul>
<li>Обе функции применимы только к числам больше или равным 0</li>
<li>Для вычисления чисел Фибоначчи без рекурсии применется решение соответствуюего им рекуррентного соотношения</li>
</ul>

### Особенности реализации функций сортировок
<ul>
<li>в radix sort применяется алгоритм LSD</li>
<li>в counting sort при слишком большой разнице между максимальным и минимальном элементе выводится Warning о возможности
переполнения памяти</li>
<li>в алгоритмах quick, bubble и heap sort есть возможность ввести ключи и компаратор</li>
<li>в файле с сортировками лежат функции-макеты для ключа и компаратора</li>
<li>для реализации алгоритма сортировки heap sort создан дополнительный класс двоичной кучи со своими методами</li>
<li>в bucket sort каждое "ведро" сортируется алгоритмом quick sort</li>
</ul>

### Особенности реализации структуры данных - стека
<ul>
<li>Стек реализован на основе связанного списка, где каждый элемент знает только следующий после себя</li>
<li>В классе есть два указателя на ноду - memory и quick_access_memory, соответственно указатель на начало стека и на
последние 5-10 элементов</li>
<li>при изменениии размера стека происходит проверка, не закончислась или не переполнилась ли quick_access_memory, если
такая ситуация имеет место, то происходит сдвиг указателя quick_access_memory</li>
<li>использование quick_access_memory помогает сделать время работы команд push и pop константным, в большей части случаев</li>
<li>в стеке есть возможность поиска минимума за константное время (обеспечивается также с помощью quick_access_memory и
хранением в ноде не только элемента стека, но и минимума на момент добавления элемента в стек)</li>
</ul>

**Замечание:** так как в ТЗ к лабораторной работе было указано, что в классе ноды должна храниться именно следующая (Node(value,
**next**)), то были предприняты вышеописанные меры оптимизации

### Особенности реализации функций генерации тестовых массивов и бенчмаркинга
<ul>
<li>в ТЗ к лабораторной работе было не указанно наличие семени генерации для массива, отсортированного в обратном порядке,
оно было добавлено</li>
<li>Для замера времени работы сортитровок они применяются по 1000 раз к каждому массиву и берётся общее время</li>
</ul>

## Бенчмаркинг
                                       bubble |                quick |                radix |             counting |                 heap |               bucket |
             common array   395.3818494869993 |    7.863476387996343 |   1.1099740779973217 |   0.6742019500015886 |   44.519752494001295 |                   -1 |
      nearly sorted array   405.5639553350047 |   12.856744431999687 |   2.4834065349932644 |    6.586286049001501 |    52.06791827499546 |                   -1 |
     reverse sorted array  392.66591917200276 |   12.867388893995667 |   2.4684875730017666 |    6.596336613998574 |    52.92264227599662 |                   -1 |
    many duplicates array  384.31777727900044 |    5.234936444998311 |   1.6990032519970555 |   1.5334979929975816 |   38.265385754995805 |                   -1 |
              float array   404.7675722569984 |   15.385622408000927 |                   -1 |                   -1 |    55.59780226399744 |    8.630516868994164 |

В данной таблице приведены результаты работы 10000 раз алгоритмов сортировки с соответствующими названиями, время приведено
в секундах, если в таблице написано -1, то сортировка не применима к данному виду массива

Из таблицы можно сделать следующие выводы:
<ul>
<li>bubble sort гораздо медленнее всех остальных</li>
<li>все алгоритмы хуже справляются с почти отсортирванными массивами и отсортированными в обратном порядке</li>
<li>Самое быстрое, в среднем, время работы у radix sort</li>
<li>деление массива на "вёдра" увеличивает скорость работы алгоритма</li>
<li>heap sort имеет достаточно большое время работы, по сравнению с другими, кроме bubble, предположительно из-за
реализации через класс</li>
</ul>

## Тестирование
Для тестирования используется модуль pytest. Также используется возможность pytest.mark.parametrize.

### Тестовые файлы

Тесты в каждом файле разделены по следующему принципу: сначала тесты базаовой работы функций, дальше идёт тестирование ошибок.
Тестирование генераторов производится параллельно тестированию сортировок.

### Примеры тестов

Тест корректности работы факториала

<pre>
@pytest.mark.parametrize("inp,expected", [(num, int(fact_math(num))) for num in range(20)])
def test_factorial(inp, expected):
    assert factorial(inp) == expected
</pre>

Для тестирования используется функция из библиотеки math (переименованна для избежания ошибок совпадения имён)

Тест корректности вычисления чисел Фибоначчи

<pre>
@pytest.mark.parametrize("inp,expected", [(1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8), (7, 13), (8, 21), (9, 34)])
def test_fibo_recursive(inp, expected):
    assert fibo_recursive(inp) == expected
</pre>

Для тестирования используются заранее вычисленные значения чисел Фибоначчи

Проверка обработки некорректного ввода в факториал и числа Фибоначчи

<pre>
def test_error_less_than_zero():
    with pytest.raises(ValueError):
        fibo_recursive(-1)
    with pytest.raises(ValueError):
        fibo(-1)
    with pytest.raises(ValueError):
        factorial_recursive(-1)
    with pytest.raises(ValueError):
        factorial(-1)
</pre>

Так как ошибка одинакова для всех функций, то решено не разделять её проверку на несколько тестов

Тестирование сортировки (на примере quick sort)

<pre>
@pytest.mark.parametrize("inp,expected", [(many_duplicates(100, 20, 42), sorted(many_duplicates(100, 20, 42))),
                                          (reverse_sorted(100, 42), sorted(reverse_sorted(100, 42))),
                                          (rand_int_array(100, 40, 120, seed=42),
                                           sorted(rand_int_array(100, 40, 120, seed=42))),
                                          (rand_float_array(100, 0, 1, 42), sorted(rand_float_array(100, 0, 1, 42))),
                                          (nearly_sorted(100, 20, 42), sorted(nearly_sorted(100, 20, 42)))])
def test_quick(inp, expected):
    assert quick_sort(inp) == expected
</pre>

Хотел бы отметить один интересный момент: стандартная функция sorted по неизвестной причине плохо обрабатывает число 38,
можете сами в этом убедиться

Ошибки при использовании сортировок

<pre>
def test_sort_errors():
    with pytest.raises(ValueError):
        bucket_sort([1000])
    with pytest.raises(ValueError):
        counting_sort([1.000])
    with pytest.raises(ValueError):
        radix_sort([1.000])
    with pytest.raises(ValueError):
        radix_sort([1, 2, 4, 1], -1)
</pre>

Базовая проверка корректности работы стека

<pre>
def test_base_stack_work():
    stack = Stack()
    for i in range(100):
        stack.push(i)
    for i in range(100):
        assert 100 - 1 - i == stack.pop()
</pre>

также этот тест дает возможность проверить корректность работы quick_access_memory

Все тесты в сумме покрывают примерно 82% кода из src. Всего есть ~86 тестов.
